#!/opt/homebrew/bin/bash

############## VARIABLES GLOBALES ##############
ERROR_MESSAGE="error"
EXIT_MESSAGE="exit"


############## FONCTIONS ##############

# V√©rifier les param√®tres lors du lancement du programme
# $1 -> destinataire
# $2 -> r√©cpteur
checkParameters() {
    # V√©rifier si le nombre de param√®tres est correct
    if [ $# -lt 1 ] || [ $# -gt 2 ]; then # si moins d'un param√®tre ou plus que deux
        # >&2 pour rediriger le message vers la sortie standard d'erreur
        echo "chat-bot destinataire [pseudo]" >&2
        exit 1
    fi

    #s'il n'y a pas de 2e argument, le r√©ceptionniste sera "bot" par d√©faut
    if [ -z "$2" ]; then
        rec="bot"
    else
        rec=$2  #r√©cepteur
    fi

    dest=$1 #destinataire
}

# Fonction qui analyse le fichier liste-bot.txt pour s'assurer si l'argument donn√©
# correspond √† un mot dans le fichier
readFile() {
    result=""
    # -r pour ignorer les caract√®res d'√©chappement
    while read -r LINE; do
        if [[ ${LINE%% *} == $1 ]]; then
            result="${LINE#* }"
        fi
    done < "liste-bot.txt"
    echo "$result"
}

# Fonction qui ferme les pipes (pour √©vit√©r les memory leaks)
cleanUp() {
    exec {MY_PROC[0]}>&-  # Fermer le pipe en lecture
    exec {MY_PROC[1]}>&-  # Fermer le pipe en √©criture
    # echo "Pipes ferm√©s."
}

manageInput() {

    if [[ "$(echo "$1" | xargs)" == "liste" ]]; then
        echo "$(ls)"

    # Identification de la commande li, s√©par√©ment du nom du fichier
    elif [[ "$(echo "$1" | xargs)" =~ ^li\   ]] || [ "$(echo "$1" | xargs)" == "li" ]; then 
        # Division de la commande en "li" et "FICHIER"
        set -- $1
        
        # V√©rification de si il y a bien un argument
        if [ $# -eq 1 ] || [ $# -gt 2 ]; then
            echo "La commande 'li' requiert un argument." >&2
            echo "$ERROR_MESSAGE"
        
        # V√©rification de si le fichier existe
        elif [ -f $2 ]; then
            local retInput=$(cat "$2")
            retInput+=""
            echo "$retInput"
        
        # Le fichier n'existe pas
        else
            echo "Le fichier $2 n'existe pas dans le r√©pertoire courant." >&2
            echo "$ERROR_MESSAGE"
        fi        

    elif [[ "$(echo "$1" | xargs)" == "qui suis-je" ]]; then
        echo "$dest"

    elif [[ "$(echo "$1" | xargs)" == "au revoir" ]]; then
        echo "$EXIT_MESSAGE"
    else
        local retFile=$(readFile "$1")
        if [[ "$retFile" == "" ]]; then
            echo "ü§ñ ?"
        else
            echo "$retFile"
        fi
    fi
}

main() {
    checkParameters "$@"
    coproc MY_PROC { ./chat "$rec" "$dest" --bot; }
    while read -r input <&"${MY_PROC[0]}"; do
        entry="${input#* }"
        ret=$(manageInput "$entry")
        if [ "$ret" == "$ERROR_MESSAGE" ] || [ "$ret" == "$EXIT_MESSAGE" ]; then
            break
        else
            echo "$ret" >&"${MY_PROC[1]}"
        fi
    done
    cleanUp
}


############## MAIN ##############

# On appelle main avec tous les arguments de lancement
main "$@"