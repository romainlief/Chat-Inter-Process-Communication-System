\documentclass[utf8]{article}

\usepackage[utf8]{inputenc}

\usepackage[parfill]{parskip}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listingsutf8}
\usepackage{amsmath}

\usepackage{fullpage}
\usepackage{hyperref}

% -----------------------------------------------------

\begin{document}

\begin{titlepage}
    \centering
    
    % Titre en haut de la page
    \vspace*{1cm}
    {\huge \bfseries Info F-201 : Projet d’OS \\
                    Rapport \par}
    
    % Espace vertical pour centrer le logo
    \vfill
    
    % Logo au milieu de la page
    \begin{figure}[h]
        \centering
        \includegraphics[scale=0.2]{logo.png}
    \end{figure}
    
    % Espace vertical pour descendre l'auteur et la date en bas
    \vfill
    
    % Auteur et date en bas de la page
    {\large Auteurs: Liefferinckx Romain, Rocca Manuel, Radu-Loghin Rares\\ 
            Matricules: 000591790, 000596086, 000590079 \\ 
            Section: INFO \par}
    {\large 2024, 10 Novembre \par}
\end{titlepage}

\newpage
\tableofcontents

\newpage

% -----------------------------------------------------

\section{Introduction}
\subsection{Présentation du projet et contexte}
\paragraph{Dans le cadre de notre cours d'OS, nous avons réalisé un projet qui consiste à implémenter un chat en C.
Ce chat, permet la communication entre deux utilisateurs via deux terminaux différents sur un même ordinateur grâce à des 
pipes nommés pour la transmission de messages. Le chat est composé de deux parties, celle décrite ci-dessus et une autre écrite en bash,
faisant office de chat-bot. Ce chat-bot est conçu pour simuler un utilisateur en répondant automatiquement à des commandes spécifiques 
envoyées par l’interlocuteur.\\
Le projet se compose donc de deux parties : le programme de chat (chat) et le script Bash (chat-bot).}

\subsection{Objectifs du projet}
\paragraph{L'objectif de ce projet est de mettre en pratique les concepts vus en cours d'OS, notamment la gestion des processus,
des signaux, la gestion de la mémoire partagée, et la communication inter-processus. 
Ce rapport décrit les choix d'implémentation, les difficultés rencontrées et les solutions mises en œuvre utilisée dans la 
construction de ce projet.}


\section{Choix d’Implémentation}
\subsection{Choix du langage}
\paragraph{Dans le cadre de ce projet, nous avions le choix entre le C et le C++ comme langage de programmation.
Nous avons fait le choix d'utiliser du C car}
\subsection{Gestion des processus}
\paragraph{}
\subsection{Gestion des signaux}
\paragraph{Pour la gestion des processus, nous avons décidé d'utiliser "sigaction" et non pas "signal" car}
\subsection{Gestion de la mémoire partagée}
\paragraph{La mémoire partagée, utilisée par le mode "--manuel", est implémentée à l'aide d'une structure "sharedMemo". Celle-ci permet une gestion
par indexage de la mémoire, sans avoir à se soucier des pointeurs. Elle est donc composée d'un entier reprenant le décalage et d'un tableau de 4096 octets,
représentant la mémoire elle-même. \\En ce qui concerne son fonctionnement, nous sommes partis sur la structure de donnée "queue". Elle
permet de récupérer facilement le premier string entré grâce au principe "first-in, first-out". Nous retrouvons les fonctions pour lire et écrire, ainsi
que celles pour initialiser la mémoire et la désallouer. Une fonction permettant la lecture complète la mémoire est également mais non-utilisée.
Finalement, chaque étape critique de la vie de la mémoire partagée est complémentée par de la gestion d'erreurs pour s'assurer de son bon fonctionnement.}
\subsection{Communication inter-processus}
\paragraph{}

\section{Difficultés Rencontrées et Solutions}
\subsection{Première difficulté: SIGINT et SIGPIPE}
\paragraph{Pour nous, la première difficulté fut celle de la gestion des signaux avec le "SIGINT" et le "SIGPIPE"}
\subsection{Deuxième difficulté: Mémoire partagée}
\paragraph{La seconde difficulté que nous avons rencontrée concerne quant à elle la façon d'implémenter la mémoire partagée. Premièrement, nous avons décidé
d'utiliser la structure "sharedMemo", expliquée plus haut, pour éviter les complications que peut apporter l'utilisation de l'arithmétique de pointeurs. Ensuite
vient le choix de la structure de donnée abstraite à utiliser pour que le fonctionnement de la mémoire corresponde à nos besoin. Nous avons d'abord opté pour
le "stack" et son principe de "last-in, first-out", mais comme nous cherchons à récupérer le premier string entré, la "queue" tombait sous le sens. Pour expliquer
brièvement notre manière de procéder, nous avons une boucle qui, lorsqu'un nouveau string est ajouté, décale tous les mots dans la mémoire vers la droite (vers la 
fin de la mémoire). Il est donc placé au début de notre espace alloué. En ce qui concerne le retrait du premier string entré, nous procédons avec un pop classique. Nous 
récupérons le dernier élément, sans oublier de placer l'index à la fin du string juste derrière celui retiré.}

\section{Solutions Originales et Améliorations}
\subsection{Gestion des variables globales}
\paragraph{Lors de la création du projet, étant donné que nous avons choisit le C comme langage de programmation, il était interdit 
d'utiliser de l'orienté objet et donc aucune variable dans les instanciations des objets. Le premier réflexe est donc de mettre
"const \textless nom de la variable\textgreater  = "valeur" lorsque celle-ci ne doit pas être modifié et "\textless nom de la variable\textgreater = "valeur" lorsqu'elle 
peut l'être. Nous avons alors fait le choix de mettre tout les variables globales non modifiable sous la forme 
"\#define \textless nom de la variable\textgreater \textless valeur\textgreater". Cela permet d'avoir une lisibilité accrue, et économiser de l'espace mémoire. Des
problèmes de compatibilité entre types pourraient apparaître, certes, mais nous n'utilisons les variables globales que comme types simples comme int ou str, tout en
faisant attention à leur contexte d'utilisation, nous permettant ainsi d'éviter ces erreurs.}

\section{Conclusion}
\paragraph{Ce projet nous a permis de mettre en pratique et de se familiariser avec les concepts vus en cours d'OS,
tels que la gestion des processus, des signaux, la gestion de la mémoire partagée, et la communication inter-processus en C.
Celui-ci, nous a appris à utiliser les outils de programmation en C comme sigaction, fork, les pipes nommés,... .
Notons par ailleurs que tous nos projets de première année de bachelier se faisaient seul. Cette expérience est donc
la première en groupe, impliquant certains avantages comme la répartition de tâches permettant à chaque membre d'avoir 
une charge de travail réduite, mais également d'autres aspects pas toujours positifs, comme la gestion d'équipe, qui peut 
parfois s'avérer laborieuse. Heureusement, cette gestion s'est faite sans accrocs dans notre groupe et nous a permis d'avoir
un aperçu du travail de groupe dans le monde professionnel.
}






\end{document}
